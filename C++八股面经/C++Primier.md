# C++ Primier

[TOC]

## 预编译、编译、链接

==预编译==：

#include <> 和include ""

搜索路径不同：

​	<>在系统规定的目录下搜索

​	""在自己的工程目录下搜索

编译：编译器将cpp文件转化为二进制文件obj

链接：链接器将obj文件与库(lib) 链接为可执行文件exe



## 输入输出

cin - 标准输入

cout - 标准输出   	 //先输出到缓冲区里面，结束后将**缓冲区**中的内容刷新到屏幕上

cerr - 输出错误

clog - 输出信息

std - 标准库的命名空间

:: - 作用域运算符

/      >> : 输入运算符

<< : 输出运算符

cin>>v1>>v2 : 顺序赋值给这两个变量

==cin可以跳过空格、制表符、换行符等空白字符==

```c++
while (std::cin>>value) //处于无效状态的istream对象会使条件变为假
{
    sum+=value;
}
```

命令行Ctrl+C是强制终止进程，Ctrl+Z是中断进程



## 注释

//  单行注释

/* */  界定符对注释，不能嵌套



## 类（class）

抽象（类）->具体（对象）

一个类定义了一个类型，以及与其相关联的一组操作



## 基本内置类型

C++是一种**静态**数据类型语言，在**编译**时进行类型检查；

C++定义了：算术类型、空类型(void)

C++对算术类型只规定了最小尺寸，没有规定具体是多大。x位 = 可以表示2^x^种状态

计算机以比特存储数据，每个比特非0即1。**可寻址的最小内存块称为字节（byte），内存的基本单元称为字（word）**

**大多数机器1字节 = 8bit ， 1字 = 32或64bit**

无符号类型unsigned可以节省空间

```c++
unsigned char c = -1;//假设char占8比特，c的值为255//0~255
signed char c2 = 256;//假设char占8比特，c2的值未定义//-128~127
```

不能将unsigned和signed一起用

进制转换：

20/*十进制*/  024/*八进制*/  0x14/*十六进制*/



## 变量

变量：具有类型、名称、可操作的存储空间。对c++程序员来说，变量(variable)和对象(object)一般是可以互换的。

### 初始化

```c++
int units_sold = 0;
int units_sold(0);
int units_sold = {0};//列表初始化
int units_sold{0};//列表初始化
//如果使用列表初始化，且初始值存在丢失信息的风险，则编译器将报错
```

默认初始化：如果定义变量没有定义初始值，则变量被赋予默认值；默认值是由变量类型决定的，同时定义变量的位置也会有影响；内置类型由定义的位置决定，**函数体之外初始化为0**。每个类各自决定其初始化对象的方式（构造函数？）

应该避免未初始化变量。

### 变量声明与定义

只声明不定义：用extern关键字

```c++
extern double pi = 3.14; //定义，不能放在函数体内部
int main()
{
    extern int i;//只声明不定义
    int j;//声明+定义
}
```

变量能且只能定义一次，但可以被声明多次。

==extern不是定义，是**声明在其他源文件中定义的非static全局变量**==

### 作用域

C++中大部分作用域都用花括号分离

作用域分为**全局作用域**和**块作用域**（在花括号内的），对应全局变量和局部变量

如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量；否则在局部变量的生命周期结束之前，局部变量会覆盖全局变量的值。也可以使用全局访问符::显式地访问全局变量(::variable)



## 复合类型：引用、指针

### 引用

为对象起的别名，把引用和它的初始值（对象）绑定在一起，而不是将初始值拷贝给引用。**引用本身并不是对象**，（没有物理空间？）所以不能定义引用的引用。引用必须初始化。

### 左值引用

```c++
int ival = 1024;
int& refVal = ival; //引用必须初始化
refVal = 2; //等同于ival = 2;
int& refVal2 = refVal; //等同于int& refVal2 = ival;
```

==C++新增右值引用==

### 指针

对地址的封装，本身就是一个对象。引用不是对象，所以不存在指向引用的指针。

取地址符（&）：获取指针所封装的地址

解引用符（*）：利用指针访问对象

```c++
int* ip1;
int* ip2;//指针定义
int ival = 42;
int* p = &ival; //p是指向ival的指针
*p = 2; //等同于ival = 2
```

### void*指针

纯粹的地址封装，**与类型无关**。可以用于存放任意对象的地址。

```c++
double obj = 3.14, *pd = &obj;
void* pv = &obj;
pv = pd;
```

### 指向指针的指针

```c++
int ival = 1024;
int* pi = &ival;
int** ppi = &pi;
```

### 指针的引用

```c++
int ival = 1024;
int* pi = &ival;
int*& r = pi; // r = &ival;

*r = 0; //等同于ival = 0；
```



## const限定符

const把变量变成一个常量，对变量的类型加以限定，变量的值不能被改变。 

**const对象必须初始化。**

如果想在多个文件之间共享const对象，必须在变量的定义之前添加**extern**关键字。

### ==const引用==

对常量的引用。不能通过一个非const引用指向一个const。

```c++
const int ival = 4;
const int& refVal = ival;
```

### ==常量指针==：

```c++
double pi = 3.14;
const double* ptr = &pi;
//ptr可变，*ptr不可变
```

### ==指针常量==：

```c++
double pi = 3.14;
double* const pip = &pi;
//pip不可变，*pip可变
```

### 常量表达式

值不会改变并且在编译过程就能得到计算结果的表达式。

```c++
const int max_files = 20;
const int limit = max_files + 1;
```

### constexpr变量

C++11规定允许将变量声明为constexpr类型，以便编译器来验证变量的值是否是一个常量表达式。

```c++
constexpr int max_files = 20;
constexpr int limit = max_files + 1;
```



## ==typedef、auto、decltype==

### typedef

类型别名：提高可读性

```c++
typedef double wages;
wages hourly, weekly;

typedef wages base, *p;//base是double的同义词，p是double*的同义词
```

==using ： C++11别名声明==

```c++
using SI = Sales_Item;
SI Item;
```

### auto

C++11新特性，让编译器通过初始值推断变量的类型

### decltype

选择并返回操作数的数据类型；只要数据类型，不要其值



## 自定义数据结构

类定义：类定义可以使用关键字class或struct，最后要加上分号

==二者默认的继承访问权限不同：struct默认是public的，class默认是private的==

数据成员定义了类的对象的具体内容，每个对象有自己的一份拷贝

编写头文件：

预处理变量有两个状态：已定义和未定义

#ifndef, #ifdef, #define, #endif是预处理器在编译之前执行的代码，在这里的作用是==**头文件保护**==

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H

#include <string>

struct Sales_data
{
      std::string bookNo;
      unsigned units_sold = 0;
      double revenue = 0.0;
};

#endif
```



## 命名空间的using声明

using namespace nameSpaceName;

头文件不应该包含using声明，因为会被拷贝到引用该头文件的文件中。



## 标准库类型string（STL）

可以当作容器，装char型。最后一位装的是'\0'。

string内存是连续的，大小是可变的，可以用下标访问。

初始化：

```c++
string s1;
string s2 = s1;
string s3 = "hiya";
string s4(10,'c');
```

 cin.ignore(std::numeric_limits < std::streamsize > ::max(), '\n');可以忽略掉之前留在输入流中的换行符

### ==string操作==

==C++中，字符串字面值并不是string对象==

| 代码            | 操作                                                         |
| --------------- | ------------------------------------------------------------ |
| cout<<st        | 将st写到输出流中                                             |
| cin>>st         | 输入到st中（碰见空字符时候停止）                             |
| getline(cin,st) | 读取一行赋值给st，返回st（碰见换行符时候停止）               |
| st.empty()      | st为空返回true，否则返回false                                |
| st.size()       | 返回st中字符个数                                             |
| st[n]           | 返回st中下表为n的字符的引用                                  |
| s1+s2           | 返回s1和s2连接后的结果。注意等号两边不能同时是字面值"xxx"，必须有一边是string定义的变量，借助string中==加号的重载==进行连接。 |
| s1=s2           | 用s2的副本代替s1中原来的字符                                 |
| s1==s2          | 判断s1和s2是否完全一样                                       |
| s1!=s2          | 判断s1和s2是否不完全一样                                     |
| <,<=,>=,>       | 利用字符在字典中的顺序进行比较                               |



## 标准库类型vector（STL）

### ==vector操作==

| vector操作                   |                                                              |
| ---------------------------- | ------------------------------------------------------------ |
| vector<T> v1;                | v1是一个空vector，潜在元素是T类型的                          |
| vector<T> v2(v1);            | v2包含有v1所有元素的副本                                     |
| vector<T> v2 = v1;           | 等价于v2(v1)                                                 |
| vector<T> v3(n, val);        | v3包含n个重复个元素，每个元素值都是val                       |
| vector<T> v4(n)              | v4包含n个重复地执行了值初始化的对象                          |
| vector<T> v5{a, b, c ...}    | v5包含了初始值个数的元素，每个元素都被赋予相应的初始值       |
| vector<T> v5 = {a, b, c ...} | 同上                                                         |
| vector<vector<T>> v6         | 二维数组                                                     |
| vec.empty()                  | 判断vec是否为空                                              |
| vec.size()                   | 判断vec元素个数                                              |
| vec.push_back(t)             | 向vec尾端添加一个值为t的元素                                 |
| vec[n]                       | 返回vec中第n个位置元素的引用                                 |
| vec1 = vec2                  | 用v2中的元素拷贝替换v1中的元素                               |
| vec1 = { a, b, c…}           | 用列表中的元素替换v1中的元素                                 |
| vec1 == vec2                 | v1、v2相等当且仅当他们的元素数量相同且对应位置的元素值都相同 |
| vec1 != vec2                 |                                                              |
| <,<=,>=.>                    | 以字典顺序进行比较                                           |



## 迭代器

使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素

有迭代器的类型都拥有begin和end成员

begin：返回指向第一个元素（或字符）的迭代器

end：**尾后迭代器**，即尾元素的下一个位置

如果容器为空，则begin和end返回的是同一个迭代器

| 代码         | 操作                                                    |
| ------------ | ------------------------------------------------------- |
| *iter        | 返回迭代器iter所指元素的引用                            |
| iter->mem    | 解引用iter并获取该元素的名为mem的成员，等价于(iter.mem) |
| /   ++iter   | 令iter指示容器中的下一个元素（尾后迭代器除外）          |
| /   --iter   | 令iter指示容器中的上一个元素                            |
| iter1==iter2 | 如果两个迭代器指示的是同一个元素则相等，否则不等        |
| iter1!=iter2 |                                                         |

尾后迭代器并不实际指示某一个元素，所以不能对其进行递增或解引用

```c++
vector<int>::iterator it;
string::iterator it2; //迭代器类型，定义在每个容器里面

vector<string> v;
auto it = v.begin();
(*it).empty();//成员访问
it->empty();//把解引用和成员访问两个操作合在一起
```

 任何一种可能改变vector对象容量的操作，都会使得相应的迭代器失效



## 数组

### 一维数组

声明： arrayType arrayName[num];

可以使用列表初始化，但必须指定数组类型，不允许使用auto

元素个数必须是常量表达式

字符数组的特殊性：字符串字面值的结尾处还有一个空字符'\0'

==数组不允许拷贝和赋值==，因为等号右边的数组名字默认为一个指向首元素的指针了，只能用for循环一个一个赋值元素

p[num]相当于指针p向后移动num个位置对应的值

### 多维数组

声明： arrayType arrayName   [num1] [num2];

```c++
int arr[3][4] = {0};// 全部元素初始化为0
int arr[3][4] = {0,3,6,9}; // {0,3,6,9,0,0,0,0,0,0,0,0}

```

size_t大部分时候是unsigned int的别名

```c++
for (auto& row : ia) //取出每一行
{
    for (auto& col : row) //取出每个数组
    {
        
    }
}
```

```c++
for (auto row : ia) //取出的数组会被编译器转换为指针
{
    for (auto col : row) //错误， int* row没有合适的begin函数
    {
        
    }
}
```



## 表达式

一元运算符：作用于一个运算对象的运算符，如取地址符（&）和解引用符（*）

二元运算符：作用于两个运算对象的运算符，如相等和乘法

三元运算符：a?b:c

运算符重载。运算对象的个数、运算符的优先级、结合律都是无法改变的。

C++表达式要么是左值，要么是右值

==左值：能取到地址的表达式==

==右值：取不到地址的表达式==（&a）

> 某些表达式的求值结果是对象，但它们是右值

==当一个对象被作用右值的时候，用的是对象的值（内存中的内容）==

==当一个对象当作左值的时候，用的是对象的身份（内存中的位置）==

如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个==引用==类型。

> 例如：对于int* p:
>
> 因为解引用生成左值，所有decltype(*p)的结果是int&
>
> 因为取地址符生成右值，所有decltype(&p)的结果是int **

对于没有指定求值顺序的运算符来说，如果表达式修改了同一个对象，将会引发错误并产生未定义行为。

> 负号的求模和取余：
>
> (-m)/n和m/(-n)都等于-(m/n)
>
> m%(-n)等于m%n，(-m)%n等于-m%n

赋值运算符左边必须是一个可修改的左值。初始化并非赋值。

















