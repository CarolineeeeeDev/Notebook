# 操作系统

[TOC]

### 1.1_1 操作系统的概念、功能和目标

作为用户和计算机硬件之间的接口

- 提供的功能
  - 命令接口（联机命令接口|脱机命令接口）
  - 程序接口
  - GUI（图形用户界面win|ios|andrio）
- 目标
  - 方便用户使用

![image-20240608143645378](images\image-20240608143645378.png)

### 1.1_2操作系统的特征

并发|并行

并发：多个事件交替发生（宏观同时发生、微观交替进行）

并行：多个事件同时发生

> ==重要考点== 并发性是操作系统一个最基本的特性
>
> 单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行
>
> 多核CPU同一时刻可以执行多个程序，多个程序可以并行地执行

共享

两种资源共享方式

- 互斥共享方式： 一个时间段内只允许一个进程访问该资源

- 同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问

  > 如果失去并发性，则系统只有一个程序在运行，共享性失去存在的意义

虚拟

概念：把一个物理上的实体变为若干个逻辑上的对应物

- 空分复用计数

- 时分复用计数

  > 如果失去并发性，则系统只有一个程序在运行，虚拟性失去存在的意义

异步

概念：在多道程序环境下，允许多个程序并发执行，但由于**资源有限**，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。

> 只有系统拥有并发性，才可能导致异步性

![image-20240608152443372](images\image-20240608152443372.png)

 

### 1.1_3操作系统的发展与分类

OS的发展与分类

- 手工操作阶段

  - 纸带机（用户独占全机、人机速度矛盾）

- 批处理阶段

  - 单道批处理系统（外围机——磁带）
  - 多道批处理系统（操作系统开始出现）

- 分时操作系统

  > 解决了人机交互问题

  - 轮流处理作业
  - 不能处理紧急任务

- 实时操作系统

  - 优先处理紧急任务
  - 硬实时系统：必须在严格的时间内完成处理
  - 软实时系统：可以偶尔犯错

- 网络操作系统

- 分布式操作系统

- 个人计算机操作系统

### **1.1_4 操作系统的运行机制与体系结构**

OS的运行机制和体系结构

- 运行机制

- 两种指令

  - 特权指令

  - 非特权指令

- 两种处理器状态

  - 核心态（root）

  - 用户态

- 两种程序

  - 内核程序(运行在核心态 )

  - 应用程序

- 变态：CPU状态转换
- 操作系统内核
  - 时钟管理（实现计时功能）
  - 中断处理
  - 原语（程序运行具有原子性，不可中断）
- 对系统资源进行管理的功能
  - 进程管理
  - 存储器管理
  - 设备管理
- 操作系统的体系结构
  - 大内核（将操作系统的主要功能模块都作为系统内核，运行在核心态）：Linux、UNIX
  - 微内核（只把最基本的功能保留在内核） ：Windows NT

![image-20240608171842835](images\image-20240608171842835.png)

![image-20240608161315492](images\image-20240608161315492.png)

### **1.1_5 中断和异常**

- 中断机制的诞生
  - 操作系统介入，开展管理工作
  - ==“用户态—>核心态”是通过中断实现的。并且中断是唯一途径==
- 中断的概念和作用
- 中断的分类
  - 内中断（异常）
    - 陷阱、陷入（trap）程序故意引发的 
    - 故障（fault）由错误条件引起的，可能被内核程序修复
    - 中止（abort）由致命错误引起，内核程序无法修复
  - 外中断 （狭义的中断）
    - 时钟中断
    - I/O中断请求

![image-20240608163639689](images\image-20240608163639689.png)

### **1.1_6 系统调用**

概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。

系统调用和库函数的区别：

- 系统调用是操作系统向上层提供的接口
- 有的库函数是对系统调用的进一步封装
- 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用

   

## 第二章 进程

### 2.1_1 进程的定义、组成、组织方式、特征

程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合

**进程**：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程。

进程是动态的，一个进程实体（进程映像）是静态的。 进程是进程实体的**运行过程**，是系统进行**资源分配和调度**的一个独立单位。

==**进程（实体）的组成**==：**PCB**（进程控制块，进程存在唯一的标志），程序段（包含程序指令），数据段（包含各种数据）

![image-20240608213210915](images\image-20240608213210915.png)



**PCB**是给**操作系统**用的；**程序段、数据段**是给**进程**自己用的

进程的特征：**动态性**（最基本的特性）、并发性、独立性、异步性、结构性

![image-20240610120746309](images\image-20240610120746309.png)

### 2.1_2 进程的状态与转换

![image-20240608215150336](images\image-20240608215150336.png)

**PCB中的state**	

​	运行状态：占有CPU，并在CPU上运行，单核只能一个进程（双核两个）（CPU√，其它资源√）

​	就绪状态：已经具备运行条件，但是没有空闲的CPU，暂时不能运行（CPUX，其它资源√）

​	阻塞状态：等在某个事件的发生，暂时不能运行（CPUX，其它资源X）

​	创建状态：创建PCB，程序段，数据段

​	终止状态：回收内存，程序段，数据段，撤销PCB

**进程状态间的转换(且只能这样转化)**

​	创建态->就绪态

​	就绪态->运行态

​	运行态->就绪态（时间片到）

​	运行态->中止态（比如数组越界）

​	运行态->阻塞态（进程**主动**）

​	阻塞态->就绪态（进程**被动**）

![image-20240608220651896](images\image-20240608220651896.png)

单CPU情况下，同一时刻只会有一个进程处于运行态；多核CPU情况下，可能有多个进程处于运行态

进程的组织方式：**链接方式**，指针指向不同的队列；**索引方式**，索引表

![image-20240608221230849](images\image-20240608221230849.png)

### 2.1_3 进程控制

进程控制：**实现各种进程状态转换**。

实现进程控制：用“**原语**”实现。

进程控制相关的原语：进程的**创建、终止、阻塞、唤醒、切换**

**原语的执行具有原子性**，运行必须一气呵成，**不可中断**。可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性。

**原语做的事情：**

​	1、更新PCB中的信息

​	2、将PCB插入合适的队列

​	3、分配/回收资源

**进程控制相关的原语：**

​	1、进程的创建：

​		创建原语：申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列

​		引起进程创建的事件：用户登录、作业调度、提供服务、应用请求

​	2、进程的终止：

​		撤销原语

​		引起进程中止的事件：正常结束、异常结束、外界干预  

​	3、进程的阻塞：

​		阻塞原语：运行态->阻塞态

​		引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作

​	4、进程的唤醒：

​		唤醒原语：阻塞态->就绪态

​		引起进程唤醒的事件：等待的事件发生

​	5、进程的切换

​		切换原语

​		引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止

在进程切换时，先**在PCB中保存这个进程的运行环境**（保存一些必要的寄存器信息），当原来的进程再次投入运行时，可以**通过PCB恢复它的运行环境**

![image-20240609124539830](images\image-20240609124539830.png)

![image-20240609124813484](images\image-20240609124813484.png)

![image-20240609124408227](images\image-20240609124408227.png)

### 2.1_4 进程通信

进程间通信（IPC）是指两个进程之间产生**数据交互**。

进程是分配系统资源的单位（包括内存地址空间），因此**各进程拥有的内存地址空间相互独立**。为了保证安全，**一个进程不能直接访问另一个进程的地址空间**。需要操作系统的帮助。

1、**共享存储**   

通过“增加页表项/段表项”将共享内存区映射到各个进程的地址空间中，各个进程对共享空间的访问是**互斥**的（如P、V操作）

基于数据结构的共享：固定分配（低级）

基于存储区的共享：划分存储区（高级）

![image-20240609130134692](images\image-20240609130134692.png)

2、**消息传递**

进程间的数据交换以**格式化的消息**为单位。进程通过操作系统提供的“**发送消息/接收消息**”两个原语进行数据交换。

消息：消息头、消息体

直接通信方式（直接挂载消息）：消息发送进程要指明接收进程的ID

间接通信方式（信箱通信方式）：间接利用信箱发送消息

3、**管道通信**（pipe）

系统调用申请一个管道文件，**先进先出**读写文件

只能**半双工通信**，某一时间段内只能实现单项的传输。如果要实现双向同时通信，则需要设置两个管道。

各进程要**互斥**地访问管道（由操作系统实现）

**当管道写满时，写进程将阻塞**，直到读进程将管道中的数据取走，即可唤醒写进程；**当管道读空时，读进程将阻塞**，直到写进程往管道中写入数据，即可唤醒读进程

管道中的数据一旦被读出，就彻底消失，因此多个进程读同一个管道时可能会错乱，对此通常有两种解决方法：一个管道允许**多个写进程，一个读进程**；允许多个写进程，多个读进程，但系统会让各个读进程**轮流**从管道中读数据（Linux方案）

![image-20240609133251998](images\image-20240609133251998.png)

### 2.1_5 线程概念和多线程模型

每个进程可以有多个线程，线程是一个**基本的CPU执行单元**，也是**程序执行流的最小单位**，进一步**提高了系统的并发度**（各线程之间也可以并发）。进程只作为除CPU之外的系统资源的分配单元。

![image-20240609134621638](images\image-20240609134621638.png)

1、线程的属性

- 线程是处理机调度的基本单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块（TCB）
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销较大

2、线程的实现方式

**用户级线程**（ULT）：

由应用管理，从用户的视角看能看到的线程

![image-20240609135942076](images\image-20240609135942076.png)

**内核级线程**（KLT）：

由操作系统管理，从操作系统内核视角看能看到的线程

![image-20240609135959056](images\image-20240609135959056.png)

n个ULT可以映射到m个KLT上（n>=m）

**内核级线程才是处理机分配的单位**

3、多线程模型

**一对一模型**

n个ULT映射到n个KLT

优点：并发能力很强

缺点：占用成本高，开销大

![image-20240609140449017](images\image-20240609140449017.png)

**多对一模型**

n个ULT映射到1个KLT

优点：开销小，效率高

缺点：容易阻塞，并发度不高

![image-20240609140525198](images\image-20240609140525198.png)

**多对多模型**

n个ULT映射到m个KLT上（n>=m）

中和以上两种优缺点

![image-20240609140545069](images\image-20240609140545069.png)

![image-20240609140604141](images\image-20240609140604141.png)

线程的状态与转换和组织与控制都与进程类似

![image-20240609142454584](images\image-20240609142454584.png)

![image-20240609142504501](images\image-20240609142504501.png)

### 2.2_1 处理机调度的概念、层次

**调度**的基本概念：通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行

**三个层次**

**高级调度（作业调度）**

作业：一个具体的任务

辅助外存与内存之间的调度，**作业调入时会建立相应的PCB**，**作业调出时才撤销PCB**，调入可由操作系统决定，调出由作业运行结束才调出。每个作业只**调入一次，调出一次**。

**中级调度（内存调度）**

**将暂时不用的进程放到外存（PCB不外放）**，提高内存利用率和系统吞吐量，**进程状态为==挂起状态==**，形成挂起队列

**低级调度（进程调度/处理机调度）**

按照某种策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的**频率很高**，一般几十毫秒一次。

**七状态模型**

![image-20240609144205906](images\image-20240609144205906.png)

**三层调度的联系、对比**

![image-20240609144253063](images\image-20240609144253063.png)

![image-20240609144455139](images\image-20240609144455139.png)

### 2.2_2 进程调度的时机、切换与过程调度方式

1、进程调度的时机

- 当前运行的进程**主动放弃**处理机（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞）
- 当前运行的进程**被动放弃**处理机（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列）

不能进行进程调度的时机

- 在处理中断的过程中

- 在操作系统内核程序临界区中（但是进程在普通临界区是可以进行调度、切换的）

  ![image-20240609170921834](images\image-20240609170921834.png)

  - 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要**互斥**地访问临界资源
  - 临界区：访问临界资源的那段代码
  - **内核程序临界区**一般是用来访问**某种内核数据结构**的，比如进程的就绪队列，导致其上锁

- 在原子操作过程中（原语）

2、进程调度的方式

**非剥夺调度方式**（**非抢占方式**）

- 只允许进程主动放弃处理机
- 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

**剥夺调度方式**（**抢占方式**）

- 进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统

3、切换与过程

- 狭义的进程调度：从就绪队列中选中一个要运行的进程
- 广义的进程调度：从就绪队列中选中一个要运行的进程+**进程切换** 

进程切换的过程主要完成了：

- 对原来运行进程各种数据的保存
- 对新的进程各种数据的恢复

注意：**进程切换是有代价的**，如果**过于频繁**的进行进程**调度、切换**，必然会使整个系统的**效率降低**

4、调度器/调度程序

调度算法决定让谁运行，时间片大小决定运行多长时间

不支持内核级线程的操作系统，调度程序的处理对象是**进程**；否则调度程序的处理对象是**内核线程**

没有其他就绪进程时，调度程序运行**闲逛进程**（idle）

### 2.2_3 调度算法的评价指标

1、**CPU利用率**

CPU利用率=CPU忙碌的时间/总时间

2、**系统吞吐量**

系统吞吐量：单位时间内完成作业的数量

系统吞吐量=总共完成了多少道作业/总共花了多少时间

3、**周转时间**

- 周转时间（**提交**作业到**完成**作业花费的时间）、平均周转时间（各作业周转时间之和/作业数）
- 带权周转时间（作业周转时间/作业实际运行的时间）、平均带权周转时间（各作业带权周转时间/作业数）

4、**等待时间**

进程或作业等待处理机状态时间的和

进程：等待被服务的时间之和

作业：建立后的等待时间+作业在外存后备队列中等待的时间

5、**响应时间**

从用户提交请求到首次产生响应所用的时间

### 2.2_4 FCFS、SJF、HRRN调度算法

1、先来先服务（FCFS）

![image-20240609182013126](images\image-20240609182013126.png)

2、短作业优先（SJF，shortest job first）

![image-20240609182512679](images\image-20240609182512679.png)

**非抢占式（SJF）**：选最短需要时间的作业先进入运行态

**抢占式（SRTN）**：有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业

在所有进程都几乎同时到达时，采用SJP调度算法的平均等待时间、平均周转时间最少；若无此前提，抢占式的短作业/进程的平均时间最少

3、高响应比优先（HRRN）

![image-20240609183830302](images\image-20240609183830302.png)

![image-20240609184303671](images\image-20240609184303671.png)

### 2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统）

1、时间片轮转算法（RR）

![image-20240609185904192](images\image-20240609185904192.png)

2、优先级调度算法

![image-20240609190847315](images\image-20240609190847315.png)

3、多级反馈队列调度算法

![image-20240609191918723](images\image-20240609191918723.png)

![image-20240609191942838](images\image-20240609191942838.png)

### 2.3_1 进程同步、进程互斥

1、**进程同步**

又称**直接制约关系**，指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上**协调**他们的**工作次序**而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

2、**进程互斥**

又称**间接制约关系**

两种资源共享方式：互斥共享方式、同时共享方式

把一个时间段内只允许一个进程使用的资源称为**临界资源**。

对临界资源的互斥访问，可以在逻辑上分为四个部分：

do{

 entry section; //**进入区** 对访问的资源检查或进行**上锁**

 critical section; //**临界区**(段) 访问临界资源的那部分代码

 exit section;  //**退出区** 负责**解锁**

 remainder section; //**剩余区** 其它处理

} while(true)

1、**空闲让进**。 空的可以直接进去

2、**忙则等待**。 繁忙不能进去

3、**有限等待**。 不能让进程等待无限长时间（保证不会饥饿）

4、**让权等待**。 进程不能进临界区时，及时释放处理机

![image-20240610004550944](images\image-20240610004550944.png)

### 2.3_2 进程互斥的软件实现方法

1、**单标志法**

![image-20240610005655307](images\image-20240610005655307.png)

可以实现互斥

存在的问题：p1要访问的话，必须p0先访问，**违背“空闲让进”原则**

2、**双标志先检查** 

![image-20240610011613689](images\image-20240610011613689.png)

主要问题：可能会**违背“忙则等待”的原则**。进入区的“检查”和“上锁”两个处理不是一气呵成的，“检查”后，“上锁”前可能发生进程切换。

3、**双标志后检查**

![image-20240610011549991](images\image-20240610011549991.png)

主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，**违反“空闲让进”和“有限等待”原则**

**会产生“饥饿”现象**

4、**Peterson 算法**

![image-20240610011520594](images\image-20240610011520594.png)

![image-20240610012455562](images\image-20240610012455562.png)

### 2.3_3 进程互斥的硬件实现方法

1、**中断屏蔽方法**

![image-20240610013646387](images\image-20240610013646387.png)

2、**TestAndSet（TSL指令）**

![image-20240610013806392](images\image-20240610013806392.png)

3、**Swap指令**

![image-20240610013854584](images\image-20240610013854584.png)

![image-20240610013918280](images\image-20240610013918280.png)

![image-20240610014543575](images\image-20240610014543575.png)

![image-20240610014556260](images\image-20240610014556260.png)

### 2.3_4 信号量机制

**信号量机制**：卓有成效的实现进程互斥、同步的方法

**信号量**：信号量是一种变量，表示系统中某种资源的数量

**原语**：一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由**关中断/开中断指令**实现的。

一对原语：**wait（S）原语**和**signal（S）原语**，分别简称**P（S）、V（S）**（括号里的信号量S是函数的参数）

1、整形信号量

![image-20240610131314988](images\image-20240610131314988.png)

2、记录型信号量

![image-20240610132157662](C:\Users\LilSc\AppData\Roaming\Typora\typora-user-images\image-20240610132157662.png)

![image-20240610132215390](C:\Users\LilSc\AppData\Roaming\Typora\typora-user-images\image-20240610132215390.png)

![image-20240610132227761](images\image-20240610132227761.png)

### 2.3_5 用信号量机制实现进程互斥、同步、前驱关系

1、实现进程互斥

**前P后V**

![image-20240610133830930](images\image-20240610133830930.png)

2、实现进程同步

**进程同步**：要让各并发进程按要求有序地推进

**前V后P**

![image-20240610134448062](images\image-20240610134448062.png)

3、实现进程的前驱关系

**前V后P**

![image-20240610135225894](images\image-20240610135225894.png)

![image-20240610135357746](images\image-20240610135357746.png)

### 2.3_6 生产者-消费者问题

![image-20240610140111476](images\image-20240610140111476.png)

实现互斥的P操作要放在实现同步的P操作之后，不然会发生死锁

V操作不会导致进程发生阻塞的状态，所以可以交换

使用操作不要放在临界区，不然并发度会降低

![image-20240610140746783](images\image-20240610140746783.png)

### 2.3_7 多生产者-多消费者模型

![image-20240610142433494](images\image-20240610142433494.png)

在生产-消费者问题中，如果**缓冲区大小为1**，那么有可能**不需要设置互斥信号量**就可以实现互斥访问缓冲区

分析同步问题时正确的分析方法：应该从“**事件**”的角度来考虑

### 2.3_8 吸烟者问题

![image-20240610143906150](images\image-20240610143906150.png)

![image-20240610144146721](images\image-20240610144146721.png)

为解决“**可以生产多个产品的单生产者**”问题提供一个思路；

若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置

### 2.3_9 读者-写者问题

1、允许多个读者同时对文件执行读操作

2、只允许一个写者往文件中写信息

3、任一写者在完成写操作之前不允许其他读者或写者工作

4、写者执行写操作前，应让已有的读者和写者全部退出

![image-20240610150009468](images\image-20240610150009468.png)

![image-20240610145218646](images\image-20240610145218646.png)

核心思想在于设置了一个**计数器count**来记录当前正在访问共享文件的读进程数。

如果需要实现一气呵成，自然应该想到用**互斥信号量**

### 2.3_10 哲学家进餐问题

五个人，必须拿左右的筷子才能吃饭

**避免死锁发生**

解决方案：

1、可以对哲学家进程施加一些限制条件，比如**最多允许四个哲学家同时进餐**，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。

2、要求**奇数**号哲学家先拿左边的筷子，然后再拿右边的筷子，而**偶数**号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。

3、仅当一个哲学家**左右两只筷子都可用**时才允许他抓起筷子。

![image-20240610152130401](images\image-20240610152130401.png)

### 2.3_11 管程

为什么要引入管程：**PV操作容易出错、困难**

![image-20240610153115484](images\image-20240610153115484.png)

心得：相当于C++的类，管程是数据放在private中，函数放在public中

拓展1：用管程解决生产者消费者问题

![image-20240610153648763](images\image-20240610153648763.png)

![image-20240610154246912](images\image-20240610154246912.png)

拓展2：Java中类似于管程的机制

![image-20240610154320400](images\image-20240610154320400.png)

![image-20240610154341727](images\image-20240610154341727.png)