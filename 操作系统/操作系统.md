# 操作系统

[TOC]

### 1.1_1 操作系统的概念、功能和目标

作为用户和计算机硬件之间的接口

- 提供的功能
  - 命令接口（联机命令接口|脱机命令接口）
  - 程序接口
  - GUI（图形用户界面win|ios|andrio）
- 目标
  - 方便用户使用

![image-20240608143645378](images\image-20240608143645378.png)

### 1.1_2操作系统的特征

并发|并行

并发：多个事件交替发生（宏观同时发生、微观交替进行）

并行：多个事件同时发生

> ==重要考点== 并发性是操作系统一个最基本的特性
>
> 单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行
>
> 多核CPU同一时刻可以执行多个程序，多个程序可以并行地执行

共享

两种资源共享方式

- 互斥共享方式： 一个时间段内只允许一个进程访问该资源

- 同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问

  > 如果失去并发性，则系统只有一个程序在运行，共享性失去存在的意义

虚拟

概念：把一个物理上的实体变为若干个逻辑上的对应物

- 空分复用计数

- 时分复用计数

  > 如果失去并发性，则系统只有一个程序在运行，虚拟性失去存在的意义

异步

概念：在多道程序环境下，允许多个程序并发执行，但由于**资源有限**，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。

> 只有系统拥有并发性，才可能导致异步性

![image-20240608152443372](images\image-20240608152443372.png)

 

### 1.1_3操作系统的发展与分类

OS的发展与分类

- 手工操作阶段

  - 纸带机（用户独占全机、人机速度矛盾）

- 批处理阶段

  - 单道批处理系统（外围机——磁带）
  - 多道批处理系统（操作系统开始出现）

- 分时操作系统

  > 解决了人机交互问题

  - 轮流处理作业
  - 不能处理紧急任务

- 实时操作系统

  - 优先处理紧急任务
  - 硬实时系统：必须在严格的时间内完成处理
  - 软实时系统：可以偶尔犯错

- 网络操作系统

- 分布式操作系统

- 个人计算机操作系统

### 1.1_4 操作系统的运行机制与体系结构

OS的运行机制和体系结构

- 运行机制

- 两种指令

  - 特权指令

  - 非特权指令

- 两种处理器状态

  - 核心态（root）

  - 用户态

- 两种程序

  - 内核程序(运行在核心态 )

  - 应用程序

- 变态：CPU状态转换
- 操作系统内核
  - 时钟管理（实现计时功能）
  - 中断处理
  - 原语（程序运行具有原子性，不可中断）
- 对系统资源进行管理的功能
  - 进程管理
  - 存储器管理
  - 设备管理
- 操作系统的体系结构
  - 大内核（将操作系统的主要功能模块都作为系统内核，运行在核心态）：Linux、UNIX
  - 微内核（只把最基本的功能保留在内核） ：Windows NT

![image-20240608171842835](images\image-20240608171842835.png)

![image-20240608161315492](images\image-20240608161315492.png)

### 1.1_5 中断和异常

- 中断机制的诞生
  - 操作系统介入，开展管理工作
  - ==“用户态—>核心态”是通过中断实现的。并且中断是唯一途径==
- 中断的概念和作用
- 中断的分类
  - 内中断（异常）
    - 陷阱、陷入（trap）程序故意引发的 
    - 故障（fault）由错误条件引起的，可能被内核程序修复
    - 中止（abort）由致命错误引起，内核程序无法修复
  - 外中断 （狭义的中断）
    - 时钟中断
    - I/O中断请求

![image-20240608163639689](images\image-20240608163639689.png)

### 1.1_6 系统调用

概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。

系统调用和库函数的区别：

- 系统调用是操作系统向上层提供的接口
- 有的库函数是对系统调用的进一步封装
- 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用

   

## 第二章 进程

### 2.1_1 进程的定义、组成、组织方式、特征

程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合

**进程**：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程。

进程是动态的，一个进程实体（进程映像）是静态的。 进程是进程实体的**运行过程**，是系统进行**资源分配和调度**的一个独立单位。

==**进程（实体）的组成**==：**PCB**（进程控制块，进程存在唯一的标志），程序段（包含程序指令），数据段（包含各种数据）

![image-20240608213210915](images\image-20240608213210915.png)



**PCB**是给**操作系统**用的；**程序段、数据段**是给**进程**自己用的

进程的特征：**动态性**（最基本的特性）、并发性、独立性、异步性、结构性

![image-20240610120746309](images\image-20240610120746309.png)

### 2.1_2 进程的状态与转换

![image-20240608215150336](images\image-20240608215150336.png)

**PCB中的state**	

​	运行状态：占有CPU，并在CPU上运行，单核只能一个进程（双核两个）（CPU√，其它资源√）

​	就绪状态：已经具备运行条件，但是没有空闲的CPU，暂时不能运行（CPUX，其它资源√）

​	阻塞状态：等在某个事件的发生，暂时不能运行（CPUX，其它资源X）

​	创建状态：创建PCB，程序段，数据段

​	终止状态：回收内存，程序段，数据段，撤销PCB

**进程状态间的转换(且只能这样转化)**

​	创建态->就绪态

​	就绪态->运行态

​	运行态->就绪态（时间片到）

​	运行态->中止态（比如数组越界）

​	运行态->阻塞态（进程**主动**）

​	阻塞态->就绪态（进程**被动**）

![image-20240608220651896](images\image-20240608220651896.png)

单CPU情况下，同一时刻只会有一个进程处于运行态；多核CPU情况下，可能有多个进程处于运行态

进程的组织方式：**链接方式**，指针指向不同的队列；**索引方式**，索引表

![image-20240608221230849](images\image-20240608221230849.png)

### 2.1_3 进程控制

进程控制：**实现各种进程状态转换**。

实现进程控制：用“**原语**”实现。

进程控制相关的原语：进程的**创建、终止、阻塞、唤醒、切换**

**原语的执行具有原子性**，运行必须一气呵成，**不可中断**。可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性。

**原语做的事情：**

​	1、更新PCB中的信息

​	2、将PCB插入合适的队列

​	3、分配/回收资源

**进程控制相关的原语：**

​	1、进程的创建：

​		创建原语：申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列

​		引起进程创建的事件：用户登录、作业调度、提供服务、应用请求

​	2、进程的终止：

​		撤销原语

​		引起进程中止的事件：正常结束、异常结束、外界干预  

​	3、进程的阻塞：

​		阻塞原语：运行态->阻塞态

​		引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作

​	4、进程的唤醒：

​		唤醒原语：阻塞态->就绪态

​		引起进程唤醒的事件：等待的事件发生

​	5、进程的切换

​		切换原语

​		引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止

在进程切换时，先**在PCB中保存这个进程的运行环境**（保存一些必要的寄存器信息），当原来的进程再次投入运行时，可以**通过PCB恢复它的运行环境**

![image-20240609124539830](images\image-20240609124539830.png)

![image-20240609124813484](images\image-20240609124813484.png)

![image-20240609124408227](images\image-20240609124408227.png)

### 2.1_4 进程通信

进程间通信（IPC）是指两个进程之间产生**数据交互**。

进程是分配系统资源的单位（包括内存地址空间），因此**各进程拥有的内存地址空间相互独立**。为了保证安全，**一个进程不能直接访问另一个进程的地址空间**。需要操作系统的帮助。

1、**共享存储**   

通过“增加页表项/段表项”将共享内存区映射到各个进程的地址空间中，各个进程对共享空间的访问是**互斥**的（如P、V操作）

基于数据结构的共享：固定分配（低级）

基于存储区的共享：划分存储区（高级）

![image-20240609130134692](images\image-20240609130134692.png)

2、**消息传递**

进程间的数据交换以**格式化的消息**为单位。进程通过操作系统提供的“**发送消息/接收消息**”两个原语进行数据交换。

消息：消息头、消息体

直接通信方式（直接挂载消息）：消息发送进程要指明接收进程的ID

间接通信方式（信箱通信方式）：间接利用信箱发送消息

3、**管道通信**（pipe）

系统调用申请一个管道文件，**先进先出**读写文件

只能**半双工通信**，某一时间段内只能实现单项的传输。如果要实现双向同时通信，则需要设置两个管道。

各进程要**互斥**地访问管道（由操作系统实现）

**当管道写满时，写进程将阻塞**，直到读进程将管道中的数据取走，即可唤醒写进程；**当管道读空时，读进程将阻塞**，直到写进程往管道中写入数据，即可唤醒读进程

管道中的数据一旦被读出，就彻底消失，因此多个进程读同一个管道时可能会错乱，对此通常有两种解决方法：一个管道允许**多个写进程，一个读进程**；允许多个写进程，多个读进程，但系统会让各个读进程**轮流**从管道中读数据（Linux方案）

![image-20240609133251998](images\image-20240609133251998.png)

### 2.1_5 线程概念和多线程模型

每个进程可以有多个线程，线程是一个**基本的CPU执行单元**，也是**程序执行流的最小单位**，进一步**提高了系统的并发度**（各线程之间也可以并发）。进程只作为除CPU之外的系统资源的分配单元。

![image-20240609134621638](images\image-20240609134621638.png)

1、线程的属性

- 线程是处理机调度的基本单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块（TCB）
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销较大

2、线程的实现方式

**用户级线程**（ULT）：

由应用管理，从用户的视角看能看到的线程

![image-20240609135942076](images\image-20240609135942076.png)

**内核级线程**（KLT）：

由操作系统管理，从操作系统内核视角看能看到的线程

![image-20240609135959056](images\image-20240609135959056.png)

n个ULT可以映射到m个KLT上（n>=m）

**内核级线程才是处理机分配的单位**

3、多线程模型

**一对一模型**

n个ULT映射到n个KLT

优点：并发能力很强

缺点：占用成本高，开销大

![image-20240609140449017](images\image-20240609140449017.png)

**多对一模型**

n个ULT映射到1个KLT

优点：开销小，效率高

缺点：容易阻塞，并发度不高

![image-20240609140525198](images\image-20240609140525198.png)

**多对多模型**

n个ULT映射到m个KLT上（n>=m）

中和以上两种优缺点

![image-20240609140545069](images\image-20240609140545069.png)

![image-20240609140604141](images\image-20240609140604141.png)

线程的状态与转换和组织与控制都与进程类似

![image-20240609142454584](images\image-20240609142454584.png)

![image-20240609142504501](images\image-20240609142504501.png)

### 2.2_1 处理机调度的概念、层次

**调度**的基本概念：通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行

**三个层次**

**高级调度（作业调度）**

作业：一个具体的任务

辅助外存与内存之间的调度，**作业调入时会建立相应的PCB**，**作业调出时才撤销PCB**，调入可由操作系统决定，调出由作业运行结束才调出。每个作业只**调入一次，调出一次**。

**中级调度（内存调度）**

**将暂时不用的进程放到外存（PCB不外放）**，提高内存利用率和系统吞吐量，**进程状态为==挂起状态==**，形成挂起队列

**低级调度（进程调度/处理机调度）**

按照某种策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的**频率很高**，一般几十毫秒一次。

**七状态模型**

![image-20240609144205906](images\image-20240609144205906.png)

**三层调度的联系、对比**

![image-20240609144253063](images\image-20240609144253063.png)

![image-20240609144455139](images\image-20240609144455139.png)

### 2.2_2 进程调度的时机、切换与过程调度方式

1、进程调度的时机

- 当前运行的进程**主动放弃**处理机（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞）
- 当前运行的进程**被动放弃**处理机（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列）

不能进行进程调度的时机

- 在处理中断的过程中

- 在操作系统内核程序临界区中（但是进程在普通临界区是可以进行调度、切换的）

  ![image-20240609170921834](images\image-20240609170921834.png)

  - 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要**互斥**地访问临界资源
  - 临界区：访问临界资源的那段代码
  - **内核程序临界区**一般是用来访问**某种内核数据结构**的，比如进程的就绪队列，导致其上锁

- 在原子操作过程中（原语）

2、进程调度的方式

**非剥夺调度方式**（**非抢占方式**）

- 只允许进程主动放弃处理机
- 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

**剥夺调度方式**（**抢占方式**）

- 进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统

3、切换与过程

- 狭义的进程调度：从就绪队列中选中一个要运行的进程
- 广义的进程调度：从就绪队列中选中一个要运行的进程+**进程切换** 

进程切换的过程主要完成了：

- 对原来运行进程各种数据的保存
- 对新的进程各种数据的恢复

注意：**进程切换是有代价的**，如果**过于频繁**的进行进程**调度、切换**，必然会使整个系统的**效率降低**

4、调度器/调度程序

调度算法决定让谁运行，时间片大小决定运行多长时间

不支持内核级线程的操作系统，调度程序的处理对象是**进程**；否则调度程序的处理对象是**内核线程**

没有其他就绪进程时，调度程序运行**闲逛进程**（idle）

### 2.2_3 调度算法的评价指标

1、**CPU利用率**

CPU利用率=CPU忙碌的时间/总时间

2、**系统吞吐量**

系统吞吐量：单位时间内完成作业的数量

系统吞吐量=总共完成了多少道作业/总共花了多少时间

3、**周转时间**

- 周转时间（**提交**作业到**完成**作业花费的时间）、平均周转时间（各作业周转时间之和/作业数）
- 带权周转时间（作业周转时间/作业实际运行的时间）、平均带权周转时间（各作业带权周转时间/作业数）

4、**等待时间**

进程或作业等待处理机状态时间的和

进程：等待被服务的时间之和

作业：建立后的等待时间+作业在外存后备队列中等待的时间

5、**响应时间**

从用户提交请求到首次产生响应所用的时间

### 2.2_4 FCFS、SJF、HRRN调度算法

1、先来先服务（FCFS）

![image-20240609182013126](images\image-20240609182013126.png)

2、短作业优先（SJF，shortest job first）

![image-20240609182512679](images\image-20240609182512679.png)

**非抢占式（SJF）**：选最短需要时间的作业先进入运行态

**抢占式（SRTN）**：有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业

在所有进程都几乎同时到达时，采用SJP调度算法的平均等待时间、平均周转时间最少；若无此前提，抢占式的短作业/进程的平均时间最少

3、高响应比优先（HRRN）

![image-20240609183830302](images\image-20240609183830302.png)

![image-20240609184303671](images\image-20240609184303671.png)

### 2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统）

1、时间片轮转算法（RR）

![image-20240609185904192](images\image-20240609185904192.png)

2、优先级调度算法

![image-20240609190847315](images\image-20240609190847315.png)

3、多级反馈队列调度算法

![image-20240609191918723](images\image-20240609191918723.png)

![image-20240609191942838](images\image-20240609191942838.png)

### 2.3_1 进程同步、进程互斥

1、**进程同步**

又称**直接制约关系**，指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上**协调**他们的**工作次序**而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

2、**进程互斥**

又称**间接制约关系**

两种资源共享方式：互斥共享方式、同时共享方式

把一个时间段内只允许一个进程使用的资源称为**临界资源**。

对临界资源的互斥访问，可以在逻辑上分为四个部分：

do{

 entry section; //**进入区** 对访问的资源检查或进行**上锁**

 critical section; //**临界区**(段) 访问临界资源的那部分代码

 exit section;  //**退出区** 负责**解锁**

 remainder section; //**剩余区** 其它处理

} while(true)

1、**空闲让进**。 空的可以直接进去

2、**忙则等待**。 繁忙不能进去

3、**有限等待**。 不能让进程等待无限长时间（保证不会饥饿）

4、**让权等待**。 进程不能进临界区时，及时释放处理机

![image-20240610004550944](images\image-20240610004550944.png)

### 2.3_2 进程互斥的软件实现方法

1、**单标志法**

![image-20240610005655307](images\image-20240610005655307.png)

可以实现互斥

存在的问题：p1要访问的话，必须p0先访问，**违背“空闲让进”原则**

2、**双标志先检查** 

![image-20240610011613689](images\image-20240610011613689.png)

主要问题：可能会**违背“忙则等待”的原则**。进入区的“检查”和“上锁”两个处理不是一气呵成的，“检查”后，“上锁”前可能发生进程切换。

3、**双标志后检查**

![image-20240610011549991](images\image-20240610011549991.png)

主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，**违反“空闲让进”和“有限等待”原则**

**会产生“饥饿”现象**

4、**Peterson 算法**

![image-20240610011520594](images\image-20240610011520594.png)

![image-20240610012455562](images\image-20240610012455562.png)

### 2.3_3 进程互斥的硬件实现方法

1、**中断屏蔽方法**

![image-20240610013646387](images\image-20240610013646387.png)

2、**TestAndSet（TSL指令）**

![image-20240610013806392](images\image-20240610013806392.png)

3、**Swap指令**

![image-20240610013854584](images\image-20240610013854584.png)

![image-20240610013918280](images\image-20240610013918280.png)

![image-20240610014543575](images\image-20240610014543575.png)

![image-20240610014556260](images\image-20240610014556260.png)

### 2.3_4 信号量机制

**信号量机制**：卓有成效的实现进程互斥、同步的方法

**信号量**：信号量是一种变量，表示系统中某种资源的数量

**原语**：一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由**关中断/开中断指令**实现的。

一对原语：**wait（S）原语**和**signal（S）原语**，分别简称**P（S）、V（S）**（括号里的信号量S是函数的参数）

1、整形信号量

![image-20240610131314988](images\image-20240610131314988.png)

2、记录型信号量

![image-20240610132157662](images\image-20240610132157662.png)

![image-20240610132215390](images\image-20240610132215390.png)

![image-20240610132227761](images\image-20240610132227761.png)

### 2.3_5 用信号量机制实现进程互斥、同步、前驱关系

1、实现进程互斥

**前P后V**

![image-20240610133830930](images\image-20240610133830930.png)

2、实现进程同步

**进程同步**：要让各并发进程按要求有序地推进

**前V后P**

![image-20240610134448062](images\image-20240610134448062.png)

3、实现进程的前驱关系

**前V后P**

![image-20240610135225894](images\image-20240610135225894.png)

![image-20240610135357746](images\image-20240610135357746.png)

### 2.3_6 生产者-消费者问题

![image-20240610140111476](images\image-20240610140111476.png)

实现互斥的P操作要放在实现同步的P操作之后，不然会发生死锁

V操作不会导致进程发生阻塞的状态，所以可以交换

使用操作不要放在临界区，不然并发度会降低

![image-20240610140746783](images\image-20240610140746783.png)

### 2.3_7 多生产者-多消费者模型

![image-20240610142433494](images\image-20240610142433494.png)

在生产-消费者问题中，如果**缓冲区大小为1**，那么有可能**不需要设置互斥信号量**就可以实现互斥访问缓冲区

分析同步问题时正确的分析方法：应该从“**事件**”的角度来考虑

### 2.3_8 吸烟者问题

![image-20240610143906150](images\image-20240610143906150.png)

![image-20240610144146721](images\image-20240610144146721.png)

为解决“**可以生产多个产品的单生产者**”问题提供一个思路；

若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置

### 2.3_9 读者-写者问题

1、允许多个读者同时对文件执行读操作

2、只允许一个写者往文件中写信息

3、任一写者在完成写操作之前不允许其他读者或写者工作

4、写者执行写操作前，应让已有的读者和写者全部退出

![image-20240610150009468](images\image-20240610150009468.png)

![image-20240610145218646](images\image-20240610145218646.png)

核心思想在于设置了一个**计数器count**来记录当前正在访问共享文件的读进程数。

如果需要实现一气呵成，自然应该想到用**互斥信号量**

### 2.3_10 哲学家进餐问题

五个人，必须拿左右的筷子才能吃饭

**避免死锁发生**

解决方案：

1、可以对哲学家进程施加一些限制条件，比如**最多允许四个哲学家同时进餐**，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。

2、要求**奇数**号哲学家先拿左边的筷子，然后再拿右边的筷子，而**偶数**号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。

3、仅当一个哲学家**左右两只筷子都可用**时才允许他抓起筷子。

![image-20240610152130401](images\image-20240610152130401.png)

### 2.3_11 管程

为什么要引入管程：**PV操作容易出错、困难**

![image-20240610153115484](images\image-20240610153115484.png)

心得：相当于C++的类，管程是数据放在private中，函数放在public中

拓展1：用管程解决生产者消费者问题

![image-20240610153648763](images\image-20240610153648763.png)

![image-20240610154246912](images\image-20240610154246912.png)

拓展2：Java中类似于管程的机制

![image-20240610154320400](images\image-20240610154320400.png)

![image-20240610154341727](images\image-20240610154341727.png)

### 2.4_1 死锁的概念

**进程死锁、饥饿、死循环的区别**

​	**死锁**：

​	定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。

​	区别：至少两个或两个的进程同时发生死锁（单进程也可能，此为错误

​	**饥饿**：

​	定义：由于长期得不到想要的资源，某进程无法向前推进的现象。

​	区别：可能只有一个进程发生饥饿

​	**死循环**：

​	定义：某进程执行过程中一直跳不出某个循环的现象。

​	区别：死循环是程序员的问题

**死锁产生的必要条件**

- **互斥条件**：多个进程争夺必须互斥使用的资源发生死锁

- **不剥夺条件**：进程获得的资源不能由其它进程强行抢夺

- **请求和保持条件**：某个进程有了资源，还在请求资源，但该资源被其他进程占有

- **循环等待条件**：存在资源的循环等待链

  ==发生死锁时一定有循环等待，但是发生循环等待时未必死锁==

**什么时候会发生死锁**

- 对系统资源的竞争
- 进程推进顺序非法
- 信号量的使用不当也会造成死锁

**死锁的处理策略**

- **预防死锁**。破坏死锁四个必要条件中的一个或几个。

- **避免死锁**。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）

- **死锁的检测和解除**。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。

  ![image-20240610210824775](images\image-20240610210824775.png)

### 2.4_2 死锁的处理策略——预防死锁

不允许死锁发生

- 静态策略：**预防死锁**
  - **破坏互斥条件**（很多时候无法破坏）
    -  把互斥的资源改造为共享资源（如SPOOLing技术）
  - **破坏不剥夺条件**（复杂，造成之前工作失效，降低系统开销，会全部放弃、导致饥饿）
    -  方案1：当某个进程请求资源得不到满足的时候，立即主动释放手里的资源
    -  方案2：由系统介入，强行帮助剥夺
  - **破坏请求和保持条件**（资源利用率极低，可能会导致某些进程饥饿）
    -  采用**静态分配**方法，一次性全部申请，如果申请不到，不要允许
  - **破坏循环等待条件**（不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源）
    -  **顺序资源分配法**：对资源编号，进程**按编号递增顺序**请求资源

![image-20240610211244570](images\image-20240610211244570.png)

### 2.4_3 死锁的处理策略——避免死锁

- 动态检测：**避免死锁**

  安全序列、不安全状态、死锁的联系

  ![image-20240610212848104](images\image-20240610212848104.png)

  ![image-20240610213429032](images\image-20240610213429032.png)

![image-20240610214142250](images\image-20240610214142250.png)

### 2.4_4 死锁的处理策略——检测和解除

死锁的检测

1、用某种数据结构来保存资源的请求和分配信息

2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态

![image-20240610215346990](images\image-20240610215346990.png)

**死锁定理**：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统**死锁**

**死锁检测算法**：依次消除与不阻塞进程相连的边，直到无边可消

死锁的解除

![image-20240610215829756](images\image-20240610215829756.png)

![image-20240610215855631](images\image-20240610215855631.png)

## 第三章 内存

### 3.1_1 内存的基础知识

![image-20240610221153471](images\image-20240610221153471.png)

==2^10^ = 1K； 2^20^ = 1M； 2^30^ = 1G==

**进程运行的基本原理**

**指令的工作原理**：

​	逻辑地址vs物理地址：**物理地址是绝对地址，逻辑地址是相对地址**

**三种装入方式**：

​	**绝对装入**：在编译的时候就知道程序放在内存的哪个位置，使用了**绝对地址**，只适用于**单道程序环境**

​	**静态重定位**：又称**可重定位装入**，装入时将**逻辑地址转表为物理地址**。特点是在一个作业装入内存时**必须分配其要求的全部内存空间**，作业一旦进入内存后，**在运行期间就不能再移动**，也不能再申请内存空间。

​	**动态重定位**：又称**动态运行时装入**，一直使用逻辑地址，把**地址转化推迟到程序真正要执行时才进行**。因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个**重定位寄存器**的支持。

从写程序到程序运行：**编辑-编译**（把高级语言翻译为机器语言）**-链接-装入**

**三种链接方式**：

​	**静态链接**：在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件

​	**装入时动态链接**：将各目标模块装入内存时，边装入边链接的链接方式

​	**运行时动态链接**（dll）：在程序执行中需要该模块时，才对它进行链接，其优点时便于修改和更新。

![image-20240610231307266](images\image-20240610231307266.png)

### 3.1_2 内存管理的概念

1、操作系统负责**内存空间的分配与回收**

2、操作系统需要提供某种技术**从逻辑上对内存空间进行扩充**

实现内存的虚拟性

3、操作系统负责从**逻辑地址到物理地址的转换**（这个过程称为**地址重定位**）

三种装入方式

4、操作系统需要提供**内存保护**功能，保证各进程在各自存储空间内运行，互不干扰

- 在CPU设置一对**上、下限寄存器**，存放进程的上、下限地址
- 采用**重定位寄存器**（**基址寄存器**）和**界地址寄存器**（**限长寄存器**）。重定位寄存器存放的是进程的**起始物理地址**，界地址寄存器中存放的是进程的**最大逻辑地址**。

![image-20240610233815962](images\image-20240610233815962.png)

### 3.1_3 覆盖与交换

内存空间的扩充

**覆盖**技术：将**程序分为多个段**，内存分为一个”**固定区**“和若干个”**覆盖区**“，需要常驻的放在”固定区“，调入后就不再调出（除非运行结束），不常用的段放在”覆盖区“，需要用到时调入内存，用不到时调出内存。缺点是**对用户不透明**，现在已经成为历史。

**交换**技术：内存空间紧张时，系统将内存中某些进程暂时**换出**外存，把外存中某些已具备运行条件的进程**换入**内存（PCB会常驻内存，不会被换出）。暂时换出外存等待的进程状态为挂起状态，进一步可细分为**就绪挂起、阻塞挂起**两种状态。

![image-20240610235557677](images\image-20240610235557677.png)

![image-20240610235626182](images\image-20240610235626182.png)

### 3.1_4 连续分配管理方式

**连续分配**：指为用户进程分配的必须是一个连续的内存空间

连续分配方式

单一连续分配：内存被分配为系统区和用户区，系统区在低地址，**用户区是一个用户独享**。优点是实现简单，**无外部碎片**。缺点是只能用于单用户、单任务的操作系统中，**有内部碎片**，存储器利用率低。

固定分区分配：将用户区分割为若干固定分区给各道程序，分割策略有**分区大小相等**和**分区大小不相等**，可以建议一个**分区说明表**来管理各个分区。每个表项包括对应分区的大小、起始地址、状态。优点是**无外部碎片**，缺点是**有内部碎片**。

![image-20240611002810196](images\image-20240611002810196.png)

动态分区分配：**可变分区分配**，不会预先划分内存分区，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。**没有内部碎片，但有外部碎片**

​	常用数据结构：空闲分区表、空闲分区链

​	选择分区：动态分区分配算法

​	分区的分配与回收：相邻的空闲分区合为一个

**内部碎片**：分配给某进程的内存区域中，如果有些部分没有用上

**外部碎片**：是指内存中的某些空闲分区由于太小而难以利用（如果有外部碎片，可以采用**紧凑技术**）

![image-20240611004751032](images\image-20240611004751032.png)

### 3.1_5 动态分区分配算法

1、**首次适应算法**（First Fit)

算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区。

实现：**空闲分区以地址递增的次序排列**。每次分配内存时顺序查找空闲分区链（或空闲分区表）

2、**最佳适应算法**(Best Fit)

算法思想：为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，优先使用更小的空闲区。

![image-20240611010425784](images\image-20240611010425784.png)

3、**最坏适应算法**(Worst Fit)

算法思想：和最佳适应算法相反，按容量递减次序排列，每次尽可能用大的分区

![image-20240611010503752](images\image-20240611010503752.png)

4、邻近适应算法(Next Fit)

算法思想：每次从上次查找结束的位置开始检索

缺点：大空间容易被用完

![image-20240611011042497](D:\Dev\Github\Notebook\操作系统\images\image-20240611011042497.png)

![image-20240611011110584](images\image-20240611011110584.png)

### 3.1_6 基本分页存储管理的基本概念

![image-20240611205800824](images\image-20240611205800824.png)

允许一个进程分散地装入道许多不相邻的位置

连续分配：为用户进程分配连续的内存空间

非连续分配：为用户进程分配分散的内存空间

将内存分为大小相等的小分区“**页框**”，将用户的进程空间也分为大小相等的一个个区域"**页/页面**"，以页框的基本单位分配给每个进程片

分页管理：物理地址=页面的其实位置+偏移量

计算机中用**2的整数倍**表示页面的大小

页表：存放页号和块号的对应关系

![image-20240611212312289](images\image-20240611212312289.png)

### 3.1_7 基本地址变换机构

![image-20240611212729850](images\image-20240611212729850.png)

![image-20240611213224393](images\image-20240611213224393.png)

![image-20240611213053800](images\image-20240611213053800.png)

### 3.1_8 具有快表的地址变换机构

1、局部性原理

时间局部性：访问某个变量后，在不久的将来还会被访问

空间局部性：程序访问了某个存储单元，不久之后，其附近的存储单元也很有可能被访问

2、什么是快表（TLB）

快表：又称联想寄存器（TLB），是一种**访问速度比内存快很多**的高速缓存（TLB不是内存！），用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为**慢表**。

3、引入快表后，地址的变换过程

![image-20240611215132667](images\image-20240611215132667.png)

![image-20240611215230027](images\image-20240611215230027.png)

![image-20240611215256833](images\image-20240611215256833.png)

### 3.1_9 两级页表

1、单级页表存在什么问题？如何解决？

所有页表项必须**连续存放**，页表过大时需要很大的连续空间

在一段时间内**并非所有页面都用得到**，因此没必要让整个页表常驻内存

2、两级页表的原理、逻辑地址结构

将长长的页表**再分页**

逻辑地址结构：（**一级页号、二级页号、页内偏移量**）

页目录表、外层页表、顶级页表

3、如何实现地址变换？

按照地址结构将逻辑地址拆分成**三部分**

从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置

根据二级页号查表，找到最终想访问的内存块号

结合页内偏移量得到物理地址

4、两级页表问题需要注意的几个细节

多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级

多级页表的访问次数（**假设没有快表结构**）——**N级页表访问一个逻辑地址需要N+1次访存**

### 3.1_10 基本分段存储管理方式

1、什么是分段？

进程的地址空间：按照程序**自身的逻辑关系**划分为若干个段，每段有段名，**每段从0开始编址**

**段号的位数决定了每个进程最多可以分几个段**

**段内地址位数决定了每个段的最大长度是多少**

2、什么是段表

段表：段映射表

每个程序被分段后，用段表记录该程序在内存中存放的位置

段表：段号 段长 基址 

3、如何实现地址变换

4、分段、分页管理的对比

页：信息的物理单位，实现离散分配，提高内存利用率，地址是一维的，访存两次

段：信息的逻辑单位，对系统可见，地址是二维的，访存3次

分段比分页更容易实现信息的共享和保护（不能被修改的代码称为纯代码和可重入代码，不属于临界资源）

![image-20240612210902732](images\image-20240612210902732.png)

![image-20240612211416280](images\image-20240612211416280.png)