# 2.数据的表示和运算

[TOC]

![image-20240512132034898](C:\Users\LilSc\AppData\Roaming\Typora\typora-user-images\image-20240512132034898.png)

![原码、反码与补码之间的相互转换](https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/1s_2s_complement.png)

![IEEE 754 标准下的 float 的计算示例](https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/ieee_754_float.png)

[浮点数编码](https://www.hello-algo.com/chapter_data_structure/number_encoding/#332)

## 2.1.1进位计数制

### r进制计数法

基数：每个数码位所用到的不同符号的个数，r进制的基数为r

> 二进制：0，1	//可使用两个稳定状态的物理器件表示；01对应逻辑真假，方便逻辑运算；方便使用逻辑门电路实现算术运算
>
> 八进制：0，1，2，3，4，5，6，7
>
> 十进制：0，1，2，3，4，5，6，7，8，9
>
> 十六进制：0，1，2，3，4，5，6，7，8，9，A，B，C，D， E，F

### 任意进制->二进制

位权：r^n^

K~n~K~n-1~...K~2~K~1~K~0~K~-1~K~-2~...K~-m~

 =K~n~ * r^n^ + K~n-1~ * r^n-1^ + ... + K~2~ * r^2^ +K~1~ * r^1^ + K~0~ * r^0^ +K~-1~ * r^-1^ + K~-2~ * r^-2^ + ... +K~-m~ * r^-m^

### 二进制<->八进制、十六进制

#### 二进制->八进制

3位一组，不足的地方补0，每组转换成对应的八进制符号

#### 二进制->十六进制

4位一组，不足的地方补0，每组转换成对应的八进制符号

#### 八进制->二进制

每位八进制对应3位二进制

#### 十六进制->二进制

每位八进制对应4位二进制

### 各种进制的常见书写方式

二进制：（...）~2~    （...）B

八进制：（...）~8~     （...）O		0（...）

十进制：（...）~10~      （...）D

十六进制：（...）~16~    	（...）H   	 0x（...）

### 十进制->任意进制

#### 整数部分

**短除法，除基取余法**

十进制数 除以基数r 得到余数K~n~即为最低位数值

#### 小数部分

**乘基取整法**

十进制数乘基数r 得到整数部分K~n~即为最高位数值，

小数部分继续乘基数r继续计算，以此循环

有的十进制小数可能存在无法用二进制精确表示的情况

可以先转换化为二进制，再转化为八进制、十六进制

### 真值和机器数

符号位：0为正，1为负

真值：符合人类习惯的数字

机器数：数字实际存到机器里的形式，正负号需要被“数字化”



## 2.1.2 BCD码

BCD码：用二进制编码的十进制

用四位数字表示一位十进制数，快速转换

### 8421码

四位数字权重为8421

> 例子：985用8421码存储：1001 1000 0101

加法运算：和二进制加法类似，如果结果落在1010~1111非法区间内，就再加6（0110）修正，得到结果

### 余3码、2421码



## 2.1.3 无符号整数的表示和运算

### 无符号整数的表示

关键字：unsigned

机器字长位数 = 通用寄存器能存的位数 = 该计算机硬件能支持的无符号整数位上限

> 现在的个人计算机机器字长通常是64位，或至少32位

强行硬塞：只能保存低位的机器字长位数的部分

无符号整数的==全部二进制位都是数值位，没有符号位，==第i位的位权是2^i-1^

==n bit无符号整数表示范围0~2^n^-1==，超出则溢出，意味着该计算机无法一次处理这么多

可以表示的最小的数：全0，可以表示最大的数：全1

### 无符号整数的加法

加法：从最低位开始，按位相加，并往更高位进位

### 无符号整数的减法

==减法：被减数不变，减数全部位按位取反，末位+1，与被减数相加==，溢出则舍弃



## 2.1.4 有符号整数的表示和运算

### 有符号整数的表示

有符号整数的表示：原码、补码、反码

有符号整数的==最高位是符号位，0表示正，1表示负==

### 原码

符号位0/1对应正/负，剩余的数值位表示真值的绝对值

若机器字长n+1位，带符号整数的原码表示范围：-(2^n^-1)~2^n^-1

真值0有两种形式：+0和-0

原码的缺点：符号位不能参与运算，需要设计复杂的硬件电路才能处理->补码的符号位可以参与运算

### 原码、补码、反码的转换

==正数：原码 = 反码 = 补码==

负数：

原码、反码、补码符号位都为1

==原码和反码相互转换：符号位不变==，数值位全部取反

==反码转换到补码：补码 = 反码末位+1==

==原码和补码相互转换==：==符号位不变==，从右往左找到第一个1，这个1左边的所有数值位按位取反

补码-2^n^无法转换为原码，因为原码最小值为-(2^n^-1)

==补码转换为反码：先转成原码，再转成反码==

### 补码

补码更便于计算机运算

用补码表示真值：符号位可以参与运算

#### 补码的加法

从最低位开始，按位相加（==符号位参与运算==），并向更高位进位，溢出则舍弃

#### 补码的减法

将减数的补码转换成负减数的补码（==全部位按位取反，末位+1==），与被减数的补码相加

类似于无符号整数的减法

计算机内部，所有带符号整数的加减法都要先转化为补码



## 2.1.5 移码

补码对符号位取反就得到移码（正数也如此），移码可表示范围和补码相同

==移码只能用于表示整数==，其它码可以用于表示小数



## 2.1.6 原/反/补/移码特性对比

![image-20240510224855052](C:\Users\LilSc\AppData\Roaming\Typora\typora-user-images\image-20240510224855052.png)



## 2.1.7 定点小数

定点整数的编码表示：原码，反码，补码，移码

定点整数隐含的小数点位置在最低位后面

定点小数的编码表示：原码，反码，补码

定点小数隐含的小数点位置在符号位后面

定点小数的运算和定点整数一模一样

![image-20240510231110983](C:\Users\LilSc\AppData\Roaming\Typora\typora-user-images\image-20240510231110983.png)

注意：位数扩展时，拓展位置不一样



## 2.2.0 奇偶校验码

奇校验码： 整个校验码（有效信息为和校验位）中“1”的个数为奇数

偶校验码： 整个校验码（有效信息为和校验位）中“1”的个数为偶数

偶校验的硬件实现：各信息进行异或（模2加）运算，等到的结果即为偶校验位



## 2.2.1 算术逻辑单元（ALU）

### 作用、大致原理

ALU主要功能：

算术运算：加、减、乘、除等

逻辑运算：与、或、非、异或等

（优先级：与>或）

辅助功能：移位，求补等

机器字长的本质：ALU可以支持一次输入输出多少位的数据

> 本质上逻辑表达式是对电路的数学化描述

复合逻辑：与非、或非、异或、同或

### 加法器的实现

略

## 2.2.2 并行进位加法器

略

## 2.2.3 补码加减运算器

略

## 2.2.4 加减运算和溢出判断，标志位的生成

略

## 2.2.5 定点数的移位运算

### 算数移位

通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权。可用移位运算实现乘法、除法。

#### 原码的算术移位

符号位保持不变，仅对数值位进行移位

右移：高位补0，低位舍弃。若舍弃的位=0，则相当于除以2；若舍弃的位不=0，则会丢失精度。

左移：低位补0，高位舍弃。若舍弃的位=0，则相当于乘以2；若舍弃的位不=0，则会丢失精度。

#### 反码的算术移位

正数和原码一样。

负数：

右移：高位补1，低位舍弃。

左移：低位补1，高位舍弃。

#### 补码的算术移位

正数和原码一样

负数：

右移：（同反码）高位补1，低位舍弃

左移：（同原码）低位补0，高位舍弃

### 逻辑移位



### 循环移位
